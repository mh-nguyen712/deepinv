
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/unfolded/demo_vanilla_unfolded.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        New to DeepInverse? Get started with the basics with the
        :ref:`5 minute quickstart tutorial <sphx_glr_auto_examples_basics_demo_quickstart.py>`.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_unfolded_demo_vanilla_unfolded.py:


Vanilla Unfolded algorithm for super-resolution
====================================================================================================

This is a simple example to show how to use vanilla unfolded Plug-and-Play.
The DnCNN denoiser and the algorithm parameters (stepsize, regularization parameters) are trained jointly.
For simplicity, we show how to train the algorithm on a  small dataset. For optimal results, use a larger dataset.

.. GENERATED FROM PYTHON SOURCE LINES 9-20

.. code-block:: Python


    import deepinv as dinv
    import torch
    from torch.utils.data import DataLoader
    from deepinv.optim.data_fidelity import L2
    from deepinv.optim.prior import PnP
    from deepinv.unfolded import unfolded_builder
    from torchvision import transforms
    from deepinv.utils import get_data_home
    from deepinv.datasets import BSDS500








.. GENERATED FROM PYTHON SOURCE LINES 21-24

Setup paths for data loading and results.
----------------------------------------------------------------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 24-35

.. code-block:: Python


    BASE_DIR = get_data_home()
    DATA_DIR = BASE_DIR / "measurements"
    RESULTS_DIR = BASE_DIR / "results"
    CKPT_DIR = BASE_DIR / "ckpts"

    # Set the global random seed from pytorch to ensure reproducibility of the example.
    torch.manual_seed(0)

    device = dinv.utils.get_freer_gpu() if torch.cuda.is_available() else "cpu"








.. GENERATED FROM PYTHON SOURCE LINES 36-39

Load base image datasets and degradation operators.
----------------------------------------------------------------------------------------
In this example, we use the CBSD500 dataset for training and the Set3C dataset for testing.

.. GENERATED FROM PYTHON SOURCE LINES 39-44

.. code-block:: Python


    img_size = 64 if torch.cuda.is_available() else 32
    n_channels = 3  # 3 for color images, 1 for gray-scale images
    operation = "super-resolution"








.. GENERATED FROM PYTHON SOURCE LINES 45-48

Generate a dataset of low resolution images and load it.
----------------------------------------------------------------------------------------
We use the Downsampling class from the physics module to generate a dataset of low resolution images.

.. GENERATED FROM PYTHON SOURCE LINES 48-102

.. code-block:: Python


    # For simplicity, we use a small dataset for training.
    # To be replaced for optimal results. For example, you can use the larger DIV2K or LSDIR datasets (also provided in the library).

    # Specify the  train and test transforms to be applied to the input images.
    test_transform = transforms.Compose(
        [transforms.CenterCrop(img_size), transforms.ToTensor()]
    )
    train_transform = transforms.Compose(
        [transforms.RandomCrop(img_size), transforms.ToTensor()]
    )
    # Define the base train and test datasets of clean images.
    train_base_dataset = BSDS500(
        BASE_DIR, download=True, train=True, transform=train_transform
    )
    test_base_dataset = BSDS500(
        BASE_DIR, download=False, train=False, transform=test_transform
    )

    # Use parallel dataloader if using a GPU to speed up training, otherwise, as all computes are on CPU, use synchronous
    # dataloading.
    num_workers = 4 if torch.cuda.is_available() else 0

    # Degradation parameters
    factor = 2
    noise_level_img = 0.03

    # Generate the gaussian blur downsampling operator.
    physics = dinv.physics.Downsampling(
        filter="gaussian",
        img_size=(n_channels, img_size, img_size),
        factor=factor,
        device=device,
        noise_model=dinv.physics.GaussianNoise(sigma=noise_level_img),
    )
    my_dataset_name = "demo_unfolded_sr"
    n_images_max = (
        None if torch.cuda.is_available() else 10
    )  # max number of images used for training (use all if you have a GPU)
    measurement_dir = DATA_DIR / "BSDS500" / operation
    generated_datasets_path = dinv.datasets.generate_dataset(
        train_dataset=train_base_dataset,
        test_dataset=test_base_dataset,
        physics=physics,
        device=device,
        save_dir=measurement_dir,
        train_datapoints=n_images_max,
        num_workers=num_workers,
        dataset_filename=str(my_dataset_name),
    )

    train_dataset = dinv.datasets.HDF5Dataset(path=generated_datasets_path, train=True)
    test_dataset = dinv.datasets.HDF5Dataset(path=generated_datasets_path, train=False)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

      0%|          | 0/167818480 [00:00<?, ?it/s]      1%|          | 832k/160M [00:00<00:21, 7.88MB/s]      3%|▎         | 5.56M/160M [00:00<00:05, 27.1MB/s]      5%|▌         | 8.31M/160M [00:00<00:05, 27.3MB/s]      7%|▋         | 11.2M/160M [00:00<00:05, 26.8MB/s]      9%|▉         | 14.1M/160M [00:00<00:05, 27.3MB/s]     11%|█         | 17.0M/160M [00:00<00:05, 26.8MB/s]     12%|█▏        | 19.9M/160M [00:00<00:05, 27.6MB/s]     14%|█▍        | 22.9M/160M [00:00<00:05, 26.9MB/s]     16%|█▌        | 25.8M/160M [00:01<00:05, 27.8MB/s]     18%|█▊        | 28.8M/160M [00:01<00:05, 27.2MB/s]     20%|█▉        | 31.8M/160M [00:01<00:04, 28.1MB/s]     22%|██▏       | 34.8M/160M [00:01<00:04, 28.9MB/s]     23%|██▎       | 37.6M/160M [00:01<00:04, 29.0MB/s]     25%|██▌       | 40.4M/160M [00:01<00:04, 29.1MB/s]     27%|██▋       | 43.2M/160M [00:01<00:04, 27.7MB/s]     29%|██▊       | 45.9M/160M [00:01<00:04, 27.7MB/s]     31%|███       | 48.9M/160M [00:01<00:04, 27.5MB/s]     32%|███▏      | 52.0M/160M [00:01<00:03, 28.6MB/s]     34%|███▍      | 55.1M/160M [00:02<00:03, 28.0MB/s]     36%|███▋      | 58.2M/160M [00:02<00:03, 28.8MB/s]     38%|███▊      | 61.3M/160M [00:02<00:03, 28.5MB/s]     40%|████      | 64.4M/160M [00:02<00:03, 29.5MB/s]     42%|████▏     | 67.6M/160M [00:02<00:03, 28.7MB/s]     44%|████▍     | 70.6M/160M [00:02<00:03, 29.6MB/s]     46%|████▌     | 73.8M/160M [00:02<00:02, 30.6MB/s]     48%|████▊     | 76.8M/160M [00:02<00:02, 30.3MB/s]     50%|████▉     | 79.7M/160M [00:02<00:02, 29.7MB/s]     52%|█████▏    | 82.6M/160M [00:03<00:02, 28.9MB/s]     53%|█████▎    | 85.5M/160M [00:03<00:02, 29.2MB/s]     55%|█████▌    | 88.7M/160M [00:03<00:02, 29.0MB/s]     57%|█████▋    | 91.9M/160M [00:03<00:02, 29.5MB/s]     59%|█████▉    | 95.1M/160M [00:03<00:02, 29.7MB/s]     61%|██████▏   | 98.2M/160M [00:03<00:02, 30.2MB/s]     63%|██████▎   | 102M/160M [00:03<00:02, 29.9MB/s]      65%|██████▌   | 105M/160M [00:03<00:01, 30.7MB/s]     67%|██████▋   | 108M/160M [00:03<00:01, 30.0MB/s]     69%|██████▉   | 111M/160M [00:04<00:01, 30.6MB/s]     72%|███████▏  | 114M/160M [00:04<00:01, 30.1MB/s]     73%|███████▎  | 118M/160M [00:04<00:01, 30.7MB/s]     76%|███████▌  | 121M/160M [00:04<00:01, 30.2MB/s]     78%|███████▊  | 124M/160M [00:04<00:01, 30.8MB/s]     79%|███████▉  | 127M/160M [00:04<00:01, 29.8MB/s]     81%|████████  | 130M/160M [00:04<00:01, 27.7MB/s]     83%|████████▎ | 133M/160M [00:04<00:01, 24.9MB/s]     84%|████████▍ | 135M/160M [00:05<00:01, 23.7MB/s]     86%|████████▌ | 137M/160M [00:05<00:01, 23.7MB/s]     87%|████████▋ | 140M/160M [00:05<00:00, 23.1MB/s]     89%|████████▊ | 142M/160M [00:05<00:00, 22.9MB/s]     90%|█████████ | 144M/160M [00:05<00:00, 22.5MB/s]     92%|█████████▏| 147M/160M [00:05<00:00, 21.3MB/s]     93%|█████████▎| 149M/160M [00:05<00:00, 18.4MB/s]     94%|█████████▍| 151M/160M [00:05<00:00, 16.8MB/s]     95%|█████████▌| 153M/160M [00:06<00:00, 16.7MB/s]     96%|█████████▋| 154M/160M [00:06<00:00, 16.8MB/s]     98%|█████████▊| 156M/160M [00:06<00:00, 16.5MB/s]     99%|█████████▊| 158M/160M [00:06<00:00, 16.6MB/s]    100%|█████████▉| 160M/160M [00:06<00:00, 17.0MB/s]    100%|██████████| 160M/160M [00:06<00:00, 25.9MB/s]
    Extracting:   0%|          | 0/2492 [00:00<?, ?it/s]    Extracting:  13%|█▎        | 328/2492 [00:00<00:00, 3271.38it/s]    Extracting:  26%|██▋       | 658/2492 [00:00<00:00, 3283.33it/s]    Extracting:  40%|███▉      | 991/2492 [00:00<00:00, 3303.44it/s]    Extracting:  53%|█████▎    | 1322/2492 [00:00<00:00, 1575.72it/s]    Extracting:  62%|██████▏   | 1557/2492 [00:00<00:00, 1294.63it/s]    Extracting:  70%|██████▉   | 1740/2492 [00:01<00:00, 1248.85it/s]    Extracting: 100%|██████████| 2492/2492 [00:01<00:00, 2115.52it/s]
    Dataset has been saved at datasets/measurements/BSDS500/super-resolution/demo_unfolded_sr0.h5




.. GENERATED FROM PYTHON SOURCE LINES 103-110

Define the unfolded PnP algorithm.
----------------------------------------------------------------------------------------
We use the helper function :func:`deepinv.unfolded.unfolded_builder` to define the Unfolded architecture.
The chosen algorithm is here DRS (Douglas-Rachford Splitting).
Note that if the prior (resp. a parameter) is initialized with a list of length max_iter,
then a distinct model (resp. parameter) is trained for each iteration.
For fixed trained model prior (resp. parameter) across iterations, initialize with a single element.

.. GENERATED FROM PYTHON SOURCE LINES 110-150

.. code-block:: Python


    # Unrolled optimization algorithm parameters
    max_iter = 5  # number of unfolded layers

    # Select the data fidelity term
    data_fidelity = L2()

    # Set up the trainable denoising prior
    # Here the prior model is common for all iterations
    prior = PnP(denoiser=dinv.models.DnCNN(depth=7, pretrained=None).to(device))

    # The parameters are initialized with a list of length max_iter, so that a distinct parameter is trained for each iteration.
    stepsize = [1.0] * max_iter  # stepsize of the algorithm
    sigma_denoiser = [
        1.0
    ] * max_iter  # noise level parameter of the denoiser (not used by DnCNN)
    beta = 1.0  # relaxation parameter of the Douglas-Rachford splitting
    params_algo = {  # wrap all the restoration parameters in a 'params_algo' dictionary
        "stepsize": stepsize,
        "g_param": sigma_denoiser,
        "beta": beta,
    }
    trainable_params = [
        "stepsize",
        "beta",
    ]  # define which parameters from 'params_algo' are trainable

    # Logging parameters
    verbose = True

    # Define the unfolded trainable model.
    model = unfolded_builder(
        iteration="DRS",
        params_algo=params_algo.copy(),
        trainable_params=trainable_params,
        data_fidelity=data_fidelity,
        max_iter=max_iter,
        prior=prior,
    )








.. GENERATED FROM PYTHON SOURCE LINES 151-154

Define the training parameters.
----------------------------------------------------------------------------------------
We use the Adam optimizer and the StepLR scheduler.

.. GENERATED FROM PYTHON SOURCE LINES 154-176

.. code-block:: Python



    # training parameters
    epochs = 5 if torch.cuda.is_available() else 2
    learning_rate = 5e-4
    train_batch_size = 32 if torch.cuda.is_available() else 1
    test_batch_size = 3

    # choose optimizer and scheduler
    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate, weight_decay=1e-8)
    scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=int(epochs * 0.8))

    # choose supervised training loss
    losses = [dinv.loss.SupLoss(metric=dinv.metric.MSE())]

    train_dataloader = DataLoader(
        train_dataset, batch_size=train_batch_size, num_workers=num_workers, shuffle=True
    )
    test_dataloader = DataLoader(
        test_dataset, batch_size=test_batch_size, num_workers=num_workers, shuffle=False
    )








.. GENERATED FROM PYTHON SOURCE LINES 177-180

Train the network
----------------------------------------------------------------------------------------
We train the network using the :class:`deepinv.Trainer` class.

.. GENERATED FROM PYTHON SOURCE LINES 180-200

.. code-block:: Python


    trainer = dinv.Trainer(
        model,
        physics=physics,
        train_dataloader=train_dataloader,
        eval_dataloader=test_dataloader,
        epochs=epochs,
        scheduler=scheduler,
        losses=losses,
        optimizer=optimizer,
        device=device,
        early_stop=True,  # set to None to disable early stopping
        save_path=str(CKPT_DIR / operation),
        verbose=verbose,
        show_progress_bar=False,  # disable progress bar for better vis in sphinx gallery.
    )

    model = trainer.train()






.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The model has 188169 trainable parameters
    Train epoch 0: TotalLoss=0.337, PSNR=6.206
    Eval epoch 0: PSNR=9.392
    Best model saved at epoch 1
    Train epoch 1: TotalLoss=0.125, PSNR=10.181
    Eval epoch 1: PSNR=10.399
    Best model saved at epoch 2




.. GENERATED FROM PYTHON SOURCE LINES 201-205

Test the network
--------------------------------------------



.. GENERATED FROM PYTHON SOURCE LINES 205-223

.. code-block:: Python

    trainer.test(test_dataloader)

    test_sample, _ = next(iter(test_dataloader))
    model.eval()
    test_sample = test_sample.to(device)

    # Get the measurements and the ground truth
    y = physics(test_sample)
    with torch.no_grad():
        rec = model(y, physics=physics)

    backprojected = physics.A_adjoint(y)

    dinv.utils.plot(
        [backprojected, rec, test_sample],
        titles=["Linear", "Reconstruction", "Ground truth"],
        suptitle="Reconstruction results",
    )



.. image-sg:: /auto_examples/unfolded/images/sphx_glr_demo_vanilla_unfolded_001.png
   :alt: Reconstruction results, Linear, Reconstruction, Ground truth
   :srcset: /auto_examples/unfolded/images/sphx_glr_demo_vanilla_unfolded_001.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Eval epoch 0: PSNR=10.399, PSNR no learning=9.623
    Test results:
    PSNR no learning: 9.623 +- 3.848
    PSNR: 10.399 +- 3.451
    /home/runner/work/deepinv/deepinv/deepinv/utils/plotting.py:379: UserWarning: This figure was using a layout engine that is incompatible with subplots_adjust and/or tight_layout; not calling subplots_adjust.
      fig.subplots_adjust(top=0.75)





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 14.943 seconds)


.. _sphx_glr_download_auto_examples_unfolded_demo_vanilla_unfolded.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: demo_vanilla_unfolded.ipynb <demo_vanilla_unfolded.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: demo_vanilla_unfolded.py <demo_vanilla_unfolded.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: demo_vanilla_unfolded.zip <demo_vanilla_unfolded.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
